import numpy as np
import os
import re

#This file converts the mesh files generated by OpenFOAM's blockMesh into files that may
#be read by Mesh.cpp.

#Open files into which to write points, faces, cells, and boundary patch specifications
points_file = open('points.dat', 'w')
faces_file = open('faces.dat', 'w')
cells_file = open('cells.dat', 'w')
boundary_file = open('boundary.dat', 'w')

#Initiate a list of lists that will hold faces for each cell
cells_faces = []

#Read files generated from open foam into lists of lines
#Remove leading and trailing unnecessary information
points_lines = open('points', 'r').readlines()[19:-3]
faces_lines = open('faces', 'r').readlines()[19:-3]
owner_lines = open('owner', 'r').readlines()[22:-4]
neighbour_lines = open('neighbour', 'r').readlines()[22:-4]
boundary_lines = open('boundary', 'r').readlines()[18:-5]

#Additionally find number of cells, indicated in owner file
with open('owner', 'r') as file:
    file_content = file.read()
patt = r"nCells:(\d+)"

# Search for the pattern and extract number of cells
match = re.search(patt, file_content)
if match:
    nr_cells = int(match.group(1))
else:
    nr_cells = None

#The relevant lines from points and faces files
#can be taken directly
points_file.writelines(points_lines)
faces_file.writelines(faces_lines)

#Assign to each cell a list of faces
#First read through owner file that
#contains owner cell of each face
for i in range(len(owner_lines)):
    if int(owner_lines[i].strip()) >= len(cells_faces):
        cells_faces.append([str(i)])
    else:
        cells_faces[int(owner_lines[i].strip())].append(str(i))

#Read through neighbour file that contains neighbour cell
#for all internal faces and append to the corresponding cells_faces
#list the index of the face.
#The faces file from OpenFOAM indexes fist all internal faces, so this
#procedure is consistent with that format
for i in range(len(neighbour_lines)):
    if int(neighbour_lines[i].strip()) >= len(cells_faces):
        cells_faces.append([str(i)])
    else:
        cells_faces[int(neighbour_lines[i].strip())].append(str(i))

#Start cells file
cells_file.write(str(nr_cells) + '\n')
cells_file.write('(\n')

#Define function to write to the cells file
#a line containing the face indices for a cell
def write_func(lst): cells_file.write(
    f"{str(len(lst))}({ ' '.join(lst) })\n")


#For all cells, write to cells file the given cell's
#list of faces
for i in range(nr_cells):
    write_func(cells_faces[i])

#Finishing bracket at end of cells file
cells_file.write(')')

#From boundary file, extract number of non-empty boundary patches
boundary_file.write(str(int(boundary_lines[0].split()[0]) - 1) + '\n')
boundary_file.write('(\n')

#Define a number that will indicate what line, in boundary_lines
#we next want to read from
ct_lines = 2

#Loop over non-empty boundary patches
for i in range(int(boundary_lines[0].split()[0]) - 1):
    # Extracting wall_name
    boundary_file.write(boundary_lines[ct_lines].strip() + '\n')
    ct_lines += 3

    #skip line containing "inGroups"
    if ('inGroups' in boundary_lines[ct_lines]):
        ct_lines += 1

    # Extracting nFaces value
    # removing the trailing semicolon
    nFaces = int(boundary_lines[ct_lines].split()[
                 1][:-1])
    boundary_file.write(str(nFaces) + '\n')
    boundary_file.write('(\n')
    ct_lines += 1

    # Extracting startFace value
    # removing the trailing semicolon
    startFace = int(boundary_lines[ct_lines].split()[1][:-1])

    #Move ct_lines to line containing name of next boundary patch
    ct_lines += 2

    # Write list of faces, starting at startFace, to line in boundary_file
    # that indicates the adjacen faces to a given boundary patch
    boundary_file.write(' '.join([str(startFace + i)
                                  for i in range(nFaces)]) + '\n')

    #Add bracket to indicate that declaration of given boundary patch is finished
    boundary_file.write(')\n')

#write final parenthesis to boundary file
boundary_file.write(')\n')
