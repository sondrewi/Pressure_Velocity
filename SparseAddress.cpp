#include "SparseAddress.H"

/*This class will hold the indices of non-zero matrix entries in a large sparse
matrix. It consists of 2 main vectors col_index and row_index. A vector
"entries" in the SparseMat class will hold the actual coefficients of the
non-zero entries of the matrix. Vector col_index will hold the column index of
each such entry in the original matrix (hence col_index size will equal size of
the entries vector). Vector row_index will contain the index (in terms of
position in the entries vector) of the first entry in each row of the original
matrix. The last entry in row_index will contain the length of the entries
vector (needed when looping over entries in last row of original matrix) Hence,
the size of row_index will be nr or rows + 1*/
SparseAddress::SparseAddress(Mesh& the_mesh) : mesh(the_mesh) {
  // Set number of equations (equal to number of cells in mesh)
  nr_equations = mesh.getNumCells();

  // Set an additional matrix band value (zero for diagonal matrix)
  // otherwise the maximal abs(i-j) for any non-zero a_ij in original matrix A
  matrix_band = 0;

  // neighbouring index
  std::vector<int> nbrs;

  // Set first entry in row_index, as this will be known to be zero
  row_index.push_back(0);

  /*Loop through cells to find non-zero off-diagonal entries of matrix
  generated by mesh. Each cell corresponds to row in original matrix A.
  A non-zero off-diagonal entry a_ij will exist
  iff cells are neighbours. Push nbr index to back of col_index. When
  all nbrs counted for a cell, set number of neighbours + 1 as corresponding
  entry in row_index (need to account for cell on diagonal as well).*/

  for (int i = 0; i < nr_equations; i++) {
    // get neighbour-cells of cell i
    nbrs = mesh.get_cell_nbrs(i);

    /*The index (in the entries vector) of the first entry of
    row i+1 of original matrix A pushed to back of row_index. Its
    index will equal (start index of row i + number of non-zero entries in row
    i)*/
    row_index.push_back(row_index[row_index.size() - 1] + nbrs.size() + 1);

    // sort neighbours to make for easier interpretation later
    std::sort(nbrs.begin(), nbrs.end());

    // Set column index of non-zero coefficients below diagonal
    for (int k = 0; k < nbrs.size(); k++) {
      if (nbrs[k] < i) {
        col_index.push_back(nbrs[k]);
      }

      // Increase matrix_band if applicable
      if (abs(i - nbrs[k]) > matrix_band) {
        matrix_band = abs(i - nbrs[k]);
      }
    }

    // Set col_index of diagonal entry a_ii
    col_index.push_back(i);

    // Set column index of non-zero coefficients above diagonal
    for (int k = 0; k < nbrs.size(); k++) {
      if (nbrs[k] > i) {
        col_index.push_back(nbrs[k]);
      }

      // If there is a non-zero coefficient in position ij, there will
      // be one in position ji, hence max matrix band for current row will
      // already have been set in loop for below-diagonals
    }
  }
}

// Return number of equations
int SparseAddress::get_nr_eqs() const { return nr_equations; }

// Return number of off-diagonal non-zero entries
int SparseAddress::nr_off_diag() const {
  return col_index.size() - nr_equations;
}

// Return matrix band
int SparseAddress::mat_band() const { return matrix_band; }

// Convert a 1D index for entries vector into a 2D index in terms of
// original matrix A
std::pair<int, int> SparseAddress::oneD_to_twoD(int i) const {
  if (i >= col_index.size()) {
    std::cerr << "Index beyond scope of matrix" << std::endl;
    exit(EXIT_FAILURE);
  }

  // Column index can be directly seen from corresponding entry in col_index
  int col = col_index[i];

  // Start with guess that index i corresponds to an entry in 0th row of
  // original matrix
  int row = 0;

  // While current row guess +1 corresponds to an entry in entries vector
  // whose index is less than i, increment row by 1
  while (row_index[row + 1] < i) {
    row += 1;
  }

  // Return pair containing row and column index in original matrix of entry i
  // in entries vector
  std::pair<int, int> coord = std::pair<int, int>(row, col);

  return coord;
}

/*Convert a row-column index pair in original matrix into an index
representing the corresponding coefficient's index in entries vector.
The trunc argument determined what happens if a_ij is a zero-entry
If trunc = true, the function will return the entries vector-index
of the next non-zero coefficient in row i of the original matrix
Else, exit and return below message */
int SparseAddress::twoD_to_oneD(int i, int j, bool trunc) const {
  // Check if size of original square matrix is respected
  if ((i > row_index.size() - 1) || (j > row_index.size() - 1)) {
    std::cerr << "Index beyond scope of matrix" << std::endl;
    exit(EXIT_FAILURE);
  }

  // Get index, in entries vector, of first coefficient in row i
  // of original matrix
  int index = row_index[i];
  int count_start = index;

  // Establish a boolean to check if coefficient's entry in entries vector
  // has been found
  bool found_index = false;

  if (!trunc) {
    // Loop over indices of entries vector known to correspond to row i
    // of original matrix A
    for (int k = count_start; k < row_index[i + 1]; k++) {
      if (col_index[k] == j) {
        found_index = true;
        index = k;
        break;
      }
    }

    // If j does not correspond to any index in relevant range stored in
    // col_index, throw exception
    if (!found_index) {
      std::cerr << "Provided indices correspond to zero-entry in matrix"
                << std::endl;
      exit(EXIT_FAILURE);
    }
  }

  else {
    // Loop over indices of entries vector known to correspond to row i
    // of iriginal matrix A
    for (int k = count_start; k < row_index[i + 1]; k++) {
      if (col_index[k] >= j) {
        found_index = true;
        index = k;
        break;
      }
    }
  }

  return index;
}

// getter function for entry in col_index
int SparseAddress::get_col_index(int index) const { return col_index[index]; }

// getter function for entry in row_index
int SparseAddress::get_row_index(int index) const { return row_index[index]; }
